Terminals unused in grammar

   Guillemets


État 11conflits: 1 décalage/réduction


Grammaire

    0 $accept: DEBUT $end

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION_LIST BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    2 DECLARATION_LIST: DECLARATION_LIST DECLARATION
    3                 | DECLARATION

    4 DECLARATION: let VARIABLE deux_pnts TYPE1 pnt_virgul
    5            | let idf deux_pnts TYPE2 pnt_virgul
    6            | constante idf deux_pnts TYPE1 egal VALEUR

    7 VALEUR: entier_pos
    8       | entier_neg
    9       | reel_pos
   10       | reel_neg

   11 VARIABLE: idf virgul VARIABLE
   12         | idf

   13 TYPE1: reel
   14      | entier

   15 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos corechet_ferm pnt_virgul

   16 INSTRUCTIONS: /* vide */
   17             | idf AFFECTATION_NOR INSTRUCTIONS
   18             | idf AFFECTATION_TAB INSTRUCTIONS
   19             | INPUT INSTRUCTIONS
   20             | OUTPUT INSTRUCTIONS
   21             | CONDITION INSTRUCTIONS
   22             | LOOP_DO INSTRUCTIONS
   23             | LOOP_FOR INSTRUCTIONS

   24 AFFECTATION_TAB: corechet_ouvr entier_pos corechet_ferm AFFECTATION_NOR

   25 AFFECTATION_NOR: affect EXPRESSION pnt_virgul

   26 EXPRESSION: EXPRESSION_ADD

   27 EXPRESSION_ADD: EXPRESSION_ADD add EXPRESSION_MULT
   28               | EXPRESSION_ADD soustract EXPRESSION_MULT
   29               | EXPRESSION_MULT

   30 EXPRESSION_MULT: EXPRESSION_MULT multipl EXPRESSION_UNARY
   31                | EXPRESSION_MULT division EXPRESSION_UNARY
   32                | EXPRESSION_UNARY

   33 EXPRESSION_UNARY: neg EXPRESSION_UNARY
   34                 | EXPRESSION_ATOM

   35 EXPRESSION_ATOM: parenthese_ouvr EXPRESSION parenthese_ferm
   36                | idf
   37                | VALEUR

   38 OPERAND: idf
   39        | VALEUR
   40        | neg OPERAND

   41 INPUT: lire parenthese_ouvr idf parenthese_ferm pnt_virgul

   42 OUTPUT: output parenthese_ouvr DANS_OUTPUT parenthese_ferm pnt_virgul

   43 DANS_OUTPUT: chaine
   44            | idf
   45            | chaine virgul DANS_OUTPUT
   46            | idf virgul DANS_OUTPUT

   47 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm SINON

   48 SINON: else_cond accolade_ouvr INSTRUCTIONS accolade_ferm
   49      | /* vide */

   50 EXPRESSION_COND: OPERAND OPERATEUR_COND OPERAND
   51                | EXPRESSION_COND and EXPRESSION_COND
   52                | EXPRESSION_COND or EXPRESSION_COND

   53 OPERATEUR_COND: inf
   54               | sup
   55               | inf_ou_egal
   56               | sup_ou_egal
   57               | identiq
   58               | diff

   59 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

   60 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm


Terminaux, suivis des règles où ils apparaissent

$end (0) 0
error (256)
MainPrgm (258) 1
idf (259) 1 5 6 11 12 17 18 36 38 41 44 46 60
pnt_virgul (260) 1 4 5 15 25 41 42 59
var (261) 1
BeginPg (262) 1
accolade_ouvr (263) 1 47 48 59 60
accolade_ferm (264) 1 47 48 59 60
EndPg (265) 1
let (266) 4 5
deux_pnts (267) 4 5 6
constante (268) 6
egal (269) 6
virgul (270) 11 45 46
reel (271) 13
entier (272) 14
entier_pos (273) 7 15 24 60
corechet_ouvr (274) 15 24
corechet_ferm (275) 15 24
entier_neg (276) 8
reel_pos (277) 9
reel_neg (278) 10
affect (279) 25
chaine (280) 43 45
if_cond (281) 47
then (282) 47
parenthese_ferm (283) 35 41 42 47 59
parenthese_ouvr (284) 35 41 42 47 59
lire (285) 41
output (286) 42
add (287) 27
soustract (288) 28
division (289) 31
multipl (290) 30
inf (291) 53
sup (292) 54
inf_ou_egal (293) 55
sup_ou_egal (294) 56
neg (295) 33 40
and (296) 51
or (297) 52
diff (298) 58
boucle_for (299) 60
from (300) 60
to (301) 60
step (302) 60
boucle_do (303) 59
boucle_while (304) 59
else_cond (305) 48
identiq (306) 57
Guillemets (307)


Non-terminaux, suivis des règles où ils apparaissent

$accept (53)
    à gauche: 0
DEBUT (54)
    à gauche: 1, à droite: 0
DECLARATION_LIST (55)
    à gauche: 2 3, à droite: 1 2
DECLARATION (56)
    à gauche: 4 5 6, à droite: 2 3
VALEUR (57)
    à gauche: 7 8 9 10, à droite: 6 37 39
VARIABLE (58)
    à gauche: 11 12, à droite: 4 11
TYPE1 (59)
    à gauche: 13 14, à droite: 4 6 15
TYPE2 (60)
    à gauche: 15, à droite: 5
INSTRUCTIONS (61)
    à gauche: 16 17 18 19 20 21 22 23, à droite: 1 17 18 19 20 21 22
    23 47 48 59 60
AFFECTATION_TAB (62)
    à gauche: 24, à droite: 18
AFFECTATION_NOR (63)
    à gauche: 25, à droite: 17 24
EXPRESSION (64)
    à gauche: 26, à droite: 25 35
EXPRESSION_ADD (65)
    à gauche: 27 28 29, à droite: 26 27 28
EXPRESSION_MULT (66)
    à gauche: 30 31 32, à droite: 27 28 29 30 31
EXPRESSION_UNARY (67)
    à gauche: 33 34, à droite: 30 31 32 33
EXPRESSION_ATOM (68)
    à gauche: 35 36 37, à droite: 34
OPERAND (69)
    à gauche: 38 39 40, à droite: 40 50
INPUT (70)
    à gauche: 41, à droite: 19
OUTPUT (71)
    à gauche: 42, à droite: 20
DANS_OUTPUT (72)
    à gauche: 43 44 45 46, à droite: 42 45 46
CONDITION (73)
    à gauche: 47, à droite: 21
SINON (74)
    à gauche: 48 49, à droite: 47
EXPRESSION_COND (75)
    à gauche: 50 51 52, à droite: 47 51 52 59
OPERATEUR_COND (76)
    à gauche: 53 54 55 56 57 58, à droite: 50
LOOP_DO (77)
    à gauche: 59, à droite: 22
LOOP_FOR (78)
    à gauche: 60, à droite: 23


état 0

    0 $accept: . DEBUT $end

    MainPrgm  décalage et aller à l'état 1

    DEBUT  aller à l'état 2


état 1

    1 DEBUT: MainPrgm . idf pnt_virgul var DECLARATION_LIST BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    idf  décalage et aller à l'état 3


état 2

    0 $accept: DEBUT . $end

    $end  décalage et aller à l'état 4


état 3

    1 DEBUT: MainPrgm idf . pnt_virgul var DECLARATION_LIST BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    pnt_virgul  décalage et aller à l'état 5


état 4

    0 $accept: DEBUT $end .

    $défaut  accepter


état 5

    1 DEBUT: MainPrgm idf pnt_virgul . var DECLARATION_LIST BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    var  décalage et aller à l'état 6


état 6

    1 DEBUT: MainPrgm idf pnt_virgul var . DECLARATION_LIST BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    let        décalage et aller à l'état 7
    constante  décalage et aller à l'état 8

    DECLARATION_LIST  aller à l'état 9
    DECLARATION       aller à l'état 10


état 7

    4 DECLARATION: let . VARIABLE deux_pnts TYPE1 pnt_virgul
    5            | let . idf deux_pnts TYPE2 pnt_virgul

    idf  décalage et aller à l'état 11

    VARIABLE  aller à l'état 12


état 8

    6 DECLARATION: constante . idf deux_pnts TYPE1 egal VALEUR

    idf  décalage et aller à l'état 13


état 9

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION_LIST . BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul
    2 DECLARATION_LIST: DECLARATION_LIST . DECLARATION

    BeginPg    décalage et aller à l'état 14
    let        décalage et aller à l'état 7
    constante  décalage et aller à l'état 8

    DECLARATION  aller à l'état 15


état 10

    3 DECLARATION_LIST: DECLARATION .

    $défaut  réduction par utilisation de la règle 3 (DECLARATION_LIST)


état 11

    5 DECLARATION: let idf . deux_pnts TYPE2 pnt_virgul
   11 VARIABLE: idf . virgul VARIABLE
   12         | idf .

    deux_pnts  décalage et aller à l'état 16
    virgul     décalage et aller à l'état 17

    deux_pnts  [réduction par utilisation de la règle 12 (VARIABLE)]


état 12

    4 DECLARATION: let VARIABLE . deux_pnts TYPE1 pnt_virgul

    deux_pnts  décalage et aller à l'état 18


état 13

    6 DECLARATION: constante idf . deux_pnts TYPE1 egal VALEUR

    deux_pnts  décalage et aller à l'état 19


état 14

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION_LIST BeginPg . accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    accolade_ouvr  décalage et aller à l'état 20


état 15

    2 DECLARATION_LIST: DECLARATION_LIST DECLARATION .

    $défaut  réduction par utilisation de la règle 2 (DECLARATION_LIST)


état 16

    5 DECLARATION: let idf deux_pnts . TYPE2 pnt_virgul

    corechet_ouvr  décalage et aller à l'état 21

    TYPE2  aller à l'état 22


état 17

   11 VARIABLE: idf virgul . VARIABLE

    idf  décalage et aller à l'état 23

    VARIABLE  aller à l'état 24


état 18

    4 DECLARATION: let VARIABLE deux_pnts . TYPE1 pnt_virgul

    reel    décalage et aller à l'état 25
    entier  décalage et aller à l'état 26

    TYPE1  aller à l'état 27


état 19

    6 DECLARATION: constante idf deux_pnts . TYPE1 egal VALEUR

    reel    décalage et aller à l'état 25
    entier  décalage et aller à l'état 26

    TYPE1  aller à l'état 28


état 20

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION_LIST BeginPg accolade_ouvr . INSTRUCTIONS accolade_ferm EndPg pnt_virgul

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 35
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 21

   15 TYPE2: corechet_ouvr . TYPE1 pnt_virgul entier_pos corechet_ferm pnt_virgul

    reel    décalage et aller à l'état 25
    entier  décalage et aller à l'état 26

    TYPE1  aller à l'état 41


état 22

    5 DECLARATION: let idf deux_pnts TYPE2 . pnt_virgul

    pnt_virgul  décalage et aller à l'état 42


état 23

   11 VARIABLE: idf . virgul VARIABLE
   12         | idf .

    virgul  décalage et aller à l'état 17

    $défaut  réduction par utilisation de la règle 12 (VARIABLE)


état 24

   11 VARIABLE: idf virgul VARIABLE .

    $défaut  réduction par utilisation de la règle 11 (VARIABLE)


état 25

   13 TYPE1: reel .

    $défaut  réduction par utilisation de la règle 13 (TYPE1)


état 26

   14 TYPE1: entier .

    $défaut  réduction par utilisation de la règle 14 (TYPE1)


état 27

    4 DECLARATION: let VARIABLE deux_pnts TYPE1 . pnt_virgul

    pnt_virgul  décalage et aller à l'état 43


état 28

    6 DECLARATION: constante idf deux_pnts TYPE1 . egal VALEUR

    egal  décalage et aller à l'état 44


état 29

   17 INSTRUCTIONS: idf . AFFECTATION_NOR INSTRUCTIONS
   18             | idf . AFFECTATION_TAB INSTRUCTIONS

    corechet_ouvr  décalage et aller à l'état 45
    affect         décalage et aller à l'état 46

    AFFECTATION_TAB  aller à l'état 47
    AFFECTATION_NOR  aller à l'état 48


état 30

   47 CONDITION: if_cond . parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm SINON

    parenthese_ouvr  décalage et aller à l'état 49


état 31

   41 INPUT: lire . parenthese_ouvr idf parenthese_ferm pnt_virgul

    parenthese_ouvr  décalage et aller à l'état 50


état 32

   42 OUTPUT: output . parenthese_ouvr DANS_OUTPUT parenthese_ferm pnt_virgul

    parenthese_ouvr  décalage et aller à l'état 51


état 33

   60 LOOP_FOR: boucle_for . idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    idf  décalage et aller à l'état 52


état 34

   59 LOOP_DO: boucle_do . accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

    accolade_ouvr  décalage et aller à l'état 53


état 35

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION_LIST BeginPg accolade_ouvr INSTRUCTIONS . accolade_ferm EndPg pnt_virgul

    accolade_ferm  décalage et aller à l'état 54


état 36

   19 INSTRUCTIONS: INPUT . INSTRUCTIONS

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 55
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 37

   20 INSTRUCTIONS: OUTPUT . INSTRUCTIONS

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 56
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 38

   21 INSTRUCTIONS: CONDITION . INSTRUCTIONS

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 57
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 39

   22 INSTRUCTIONS: LOOP_DO . INSTRUCTIONS

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 58
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 40

   23 INSTRUCTIONS: LOOP_FOR . INSTRUCTIONS

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 59
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 41

   15 TYPE2: corechet_ouvr TYPE1 . pnt_virgul entier_pos corechet_ferm pnt_virgul

    pnt_virgul  décalage et aller à l'état 60


état 42

    5 DECLARATION: let idf deux_pnts TYPE2 pnt_virgul .

    $défaut  réduction par utilisation de la règle 5 (DECLARATION)


état 43

    4 DECLARATION: let VARIABLE deux_pnts TYPE1 pnt_virgul .

    $défaut  réduction par utilisation de la règle 4 (DECLARATION)


état 44

    6 DECLARATION: constante idf deux_pnts TYPE1 egal . VALEUR

    entier_pos  décalage et aller à l'état 61
    entier_neg  décalage et aller à l'état 62
    reel_pos    décalage et aller à l'état 63
    reel_neg    décalage et aller à l'état 64

    VALEUR  aller à l'état 65


état 45

   24 AFFECTATION_TAB: corechet_ouvr . entier_pos corechet_ferm AFFECTATION_NOR

    entier_pos  décalage et aller à l'état 66


état 46

   25 AFFECTATION_NOR: affect . EXPRESSION pnt_virgul

    idf              décalage et aller à l'état 67
    entier_pos       décalage et aller à l'état 61
    entier_neg       décalage et aller à l'état 62
    reel_pos         décalage et aller à l'état 63
    reel_neg         décalage et aller à l'état 64
    parenthese_ouvr  décalage et aller à l'état 68
    neg              décalage et aller à l'état 69

    VALEUR            aller à l'état 70
    EXPRESSION        aller à l'état 71
    EXPRESSION_ADD    aller à l'état 72
    EXPRESSION_MULT   aller à l'état 73
    EXPRESSION_UNARY  aller à l'état 74
    EXPRESSION_ATOM   aller à l'état 75


état 47

   18 INSTRUCTIONS: idf AFFECTATION_TAB . INSTRUCTIONS

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 76
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 48

   17 INSTRUCTIONS: idf AFFECTATION_NOR . INSTRUCTIONS

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 77
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 49

   47 CONDITION: if_cond parenthese_ouvr . EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm SINON

    idf         décalage et aller à l'état 78
    entier_pos  décalage et aller à l'état 61
    entier_neg  décalage et aller à l'état 62
    reel_pos    décalage et aller à l'état 63
    reel_neg    décalage et aller à l'état 64
    neg         décalage et aller à l'état 79

    VALEUR           aller à l'état 80
    OPERAND          aller à l'état 81
    EXPRESSION_COND  aller à l'état 82


état 50

   41 INPUT: lire parenthese_ouvr . idf parenthese_ferm pnt_virgul

    idf  décalage et aller à l'état 83


état 51

   42 OUTPUT: output parenthese_ouvr . DANS_OUTPUT parenthese_ferm pnt_virgul

    idf     décalage et aller à l'état 84
    chaine  décalage et aller à l'état 85

    DANS_OUTPUT  aller à l'état 86


état 52

   60 LOOP_FOR: boucle_for idf . from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    from  décalage et aller à l'état 87


état 53

   59 LOOP_DO: boucle_do accolade_ouvr . INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 88
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 54

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION_LIST BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm . EndPg pnt_virgul

    EndPg  décalage et aller à l'état 89


état 55

   19 INSTRUCTIONS: INPUT INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 19 (INSTRUCTIONS)


état 56

   20 INSTRUCTIONS: OUTPUT INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 20 (INSTRUCTIONS)


état 57

   21 INSTRUCTIONS: CONDITION INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 21 (INSTRUCTIONS)


état 58

   22 INSTRUCTIONS: LOOP_DO INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 22 (INSTRUCTIONS)


état 59

   23 INSTRUCTIONS: LOOP_FOR INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 23 (INSTRUCTIONS)


état 60

   15 TYPE2: corechet_ouvr TYPE1 pnt_virgul . entier_pos corechet_ferm pnt_virgul

    entier_pos  décalage et aller à l'état 90


état 61

    7 VALEUR: entier_pos .

    $défaut  réduction par utilisation de la règle 7 (VALEUR)


état 62

    8 VALEUR: entier_neg .

    $défaut  réduction par utilisation de la règle 8 (VALEUR)


état 63

    9 VALEUR: reel_pos .

    $défaut  réduction par utilisation de la règle 9 (VALEUR)


état 64

   10 VALEUR: reel_neg .

    $défaut  réduction par utilisation de la règle 10 (VALEUR)


état 65

    6 DECLARATION: constante idf deux_pnts TYPE1 egal VALEUR .

    $défaut  réduction par utilisation de la règle 6 (DECLARATION)


état 66

   24 AFFECTATION_TAB: corechet_ouvr entier_pos . corechet_ferm AFFECTATION_NOR

    corechet_ferm  décalage et aller à l'état 91


état 67

   36 EXPRESSION_ATOM: idf .

    $défaut  réduction par utilisation de la règle 36 (EXPRESSION_ATOM)


état 68

   35 EXPRESSION_ATOM: parenthese_ouvr . EXPRESSION parenthese_ferm

    idf              décalage et aller à l'état 67
    entier_pos       décalage et aller à l'état 61
    entier_neg       décalage et aller à l'état 62
    reel_pos         décalage et aller à l'état 63
    reel_neg         décalage et aller à l'état 64
    parenthese_ouvr  décalage et aller à l'état 68
    neg              décalage et aller à l'état 69

    VALEUR            aller à l'état 70
    EXPRESSION        aller à l'état 92
    EXPRESSION_ADD    aller à l'état 72
    EXPRESSION_MULT   aller à l'état 73
    EXPRESSION_UNARY  aller à l'état 74
    EXPRESSION_ATOM   aller à l'état 75


état 69

   33 EXPRESSION_UNARY: neg . EXPRESSION_UNARY

    idf              décalage et aller à l'état 67
    entier_pos       décalage et aller à l'état 61
    entier_neg       décalage et aller à l'état 62
    reel_pos         décalage et aller à l'état 63
    reel_neg         décalage et aller à l'état 64
    parenthese_ouvr  décalage et aller à l'état 68
    neg              décalage et aller à l'état 69

    VALEUR            aller à l'état 70
    EXPRESSION_UNARY  aller à l'état 93
    EXPRESSION_ATOM   aller à l'état 75


état 70

   37 EXPRESSION_ATOM: VALEUR .

    $défaut  réduction par utilisation de la règle 37 (EXPRESSION_ATOM)


état 71

   25 AFFECTATION_NOR: affect EXPRESSION . pnt_virgul

    pnt_virgul  décalage et aller à l'état 94


état 72

   26 EXPRESSION: EXPRESSION_ADD .
   27 EXPRESSION_ADD: EXPRESSION_ADD . add EXPRESSION_MULT
   28               | EXPRESSION_ADD . soustract EXPRESSION_MULT

    add        décalage et aller à l'état 95
    soustract  décalage et aller à l'état 96

    $défaut  réduction par utilisation de la règle 26 (EXPRESSION)


état 73

   29 EXPRESSION_ADD: EXPRESSION_MULT .
   30 EXPRESSION_MULT: EXPRESSION_MULT . multipl EXPRESSION_UNARY
   31                | EXPRESSION_MULT . division EXPRESSION_UNARY

    division  décalage et aller à l'état 97
    multipl   décalage et aller à l'état 98

    $défaut  réduction par utilisation de la règle 29 (EXPRESSION_ADD)


état 74

   32 EXPRESSION_MULT: EXPRESSION_UNARY .

    $défaut  réduction par utilisation de la règle 32 (EXPRESSION_MULT)


état 75

   34 EXPRESSION_UNARY: EXPRESSION_ATOM .

    $défaut  réduction par utilisation de la règle 34 (EXPRESSION_UNARY)


état 76

   18 INSTRUCTIONS: idf AFFECTATION_TAB INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 18 (INSTRUCTIONS)


état 77

   17 INSTRUCTIONS: idf AFFECTATION_NOR INSTRUCTIONS .

    $défaut  réduction par utilisation de la règle 17 (INSTRUCTIONS)


état 78

   38 OPERAND: idf .

    $défaut  réduction par utilisation de la règle 38 (OPERAND)


état 79

   40 OPERAND: neg . OPERAND

    idf         décalage et aller à l'état 78
    entier_pos  décalage et aller à l'état 61
    entier_neg  décalage et aller à l'état 62
    reel_pos    décalage et aller à l'état 63
    reel_neg    décalage et aller à l'état 64
    neg         décalage et aller à l'état 79

    VALEUR   aller à l'état 80
    OPERAND  aller à l'état 99


état 80

   39 OPERAND: VALEUR .

    $défaut  réduction par utilisation de la règle 39 (OPERAND)


état 81

   50 EXPRESSION_COND: OPERAND . OPERATEUR_COND OPERAND

    inf          décalage et aller à l'état 100
    sup          décalage et aller à l'état 101
    inf_ou_egal  décalage et aller à l'état 102
    sup_ou_egal  décalage et aller à l'état 103
    diff         décalage et aller à l'état 104
    identiq      décalage et aller à l'état 105

    OPERATEUR_COND  aller à l'état 106


état 82

   47 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND . parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm SINON
   51 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   52                | EXPRESSION_COND . or EXPRESSION_COND

    parenthese_ferm  décalage et aller à l'état 107
    and              décalage et aller à l'état 108
    or               décalage et aller à l'état 109


état 83

   41 INPUT: lire parenthese_ouvr idf . parenthese_ferm pnt_virgul

    parenthese_ferm  décalage et aller à l'état 110


état 84

   44 DANS_OUTPUT: idf .
   46            | idf . virgul DANS_OUTPUT

    virgul  décalage et aller à l'état 111

    $défaut  réduction par utilisation de la règle 44 (DANS_OUTPUT)


état 85

   43 DANS_OUTPUT: chaine .
   45            | chaine . virgul DANS_OUTPUT

    virgul  décalage et aller à l'état 112

    $défaut  réduction par utilisation de la règle 43 (DANS_OUTPUT)


état 86

   42 OUTPUT: output parenthese_ouvr DANS_OUTPUT . parenthese_ferm pnt_virgul

    parenthese_ferm  décalage et aller à l'état 113


état 87

   60 LOOP_FOR: boucle_for idf from . entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    entier_pos  décalage et aller à l'état 114


état 88

   59 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS . accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

    accolade_ferm  décalage et aller à l'état 115


état 89

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION_LIST BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg . pnt_virgul

    pnt_virgul  décalage et aller à l'état 116


état 90

   15 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos . corechet_ferm pnt_virgul

    corechet_ferm  décalage et aller à l'état 117


état 91

   24 AFFECTATION_TAB: corechet_ouvr entier_pos corechet_ferm . AFFECTATION_NOR

    affect  décalage et aller à l'état 46

    AFFECTATION_NOR  aller à l'état 118


état 92

   35 EXPRESSION_ATOM: parenthese_ouvr EXPRESSION . parenthese_ferm

    parenthese_ferm  décalage et aller à l'état 119


état 93

   33 EXPRESSION_UNARY: neg EXPRESSION_UNARY .

    $défaut  réduction par utilisation de la règle 33 (EXPRESSION_UNARY)


état 94

   25 AFFECTATION_NOR: affect EXPRESSION pnt_virgul .

    $défaut  réduction par utilisation de la règle 25 (AFFECTATION_NOR)


état 95

   27 EXPRESSION_ADD: EXPRESSION_ADD add . EXPRESSION_MULT

    idf              décalage et aller à l'état 67
    entier_pos       décalage et aller à l'état 61
    entier_neg       décalage et aller à l'état 62
    reel_pos         décalage et aller à l'état 63
    reel_neg         décalage et aller à l'état 64
    parenthese_ouvr  décalage et aller à l'état 68
    neg              décalage et aller à l'état 69

    VALEUR            aller à l'état 70
    EXPRESSION_MULT   aller à l'état 120
    EXPRESSION_UNARY  aller à l'état 74
    EXPRESSION_ATOM   aller à l'état 75


état 96

   28 EXPRESSION_ADD: EXPRESSION_ADD soustract . EXPRESSION_MULT

    idf              décalage et aller à l'état 67
    entier_pos       décalage et aller à l'état 61
    entier_neg       décalage et aller à l'état 62
    reel_pos         décalage et aller à l'état 63
    reel_neg         décalage et aller à l'état 64
    parenthese_ouvr  décalage et aller à l'état 68
    neg              décalage et aller à l'état 69

    VALEUR            aller à l'état 70
    EXPRESSION_MULT   aller à l'état 121
    EXPRESSION_UNARY  aller à l'état 74
    EXPRESSION_ATOM   aller à l'état 75


état 97

   31 EXPRESSION_MULT: EXPRESSION_MULT division . EXPRESSION_UNARY

    idf              décalage et aller à l'état 67
    entier_pos       décalage et aller à l'état 61
    entier_neg       décalage et aller à l'état 62
    reel_pos         décalage et aller à l'état 63
    reel_neg         décalage et aller à l'état 64
    parenthese_ouvr  décalage et aller à l'état 68
    neg              décalage et aller à l'état 69

    VALEUR            aller à l'état 70
    EXPRESSION_UNARY  aller à l'état 122
    EXPRESSION_ATOM   aller à l'état 75


état 98

   30 EXPRESSION_MULT: EXPRESSION_MULT multipl . EXPRESSION_UNARY

    idf              décalage et aller à l'état 67
    entier_pos       décalage et aller à l'état 61
    entier_neg       décalage et aller à l'état 62
    reel_pos         décalage et aller à l'état 63
    reel_neg         décalage et aller à l'état 64
    parenthese_ouvr  décalage et aller à l'état 68
    neg              décalage et aller à l'état 69

    VALEUR            aller à l'état 70
    EXPRESSION_UNARY  aller à l'état 123
    EXPRESSION_ATOM   aller à l'état 75


état 99

   40 OPERAND: neg OPERAND .

    $défaut  réduction par utilisation de la règle 40 (OPERAND)


état 100

   53 OPERATEUR_COND: inf .

    $défaut  réduction par utilisation de la règle 53 (OPERATEUR_COND)


état 101

   54 OPERATEUR_COND: sup .

    $défaut  réduction par utilisation de la règle 54 (OPERATEUR_COND)


état 102

   55 OPERATEUR_COND: inf_ou_egal .

    $défaut  réduction par utilisation de la règle 55 (OPERATEUR_COND)


état 103

   56 OPERATEUR_COND: sup_ou_egal .

    $défaut  réduction par utilisation de la règle 56 (OPERATEUR_COND)


état 104

   58 OPERATEUR_COND: diff .

    $défaut  réduction par utilisation de la règle 58 (OPERATEUR_COND)


état 105

   57 OPERATEUR_COND: identiq .

    $défaut  réduction par utilisation de la règle 57 (OPERATEUR_COND)


état 106

   50 EXPRESSION_COND: OPERAND OPERATEUR_COND . OPERAND

    idf         décalage et aller à l'état 78
    entier_pos  décalage et aller à l'état 61
    entier_neg  décalage et aller à l'état 62
    reel_pos    décalage et aller à l'état 63
    reel_neg    décalage et aller à l'état 64
    neg         décalage et aller à l'état 79

    VALEUR   aller à l'état 80
    OPERAND  aller à l'état 124


état 107

   47 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm . then accolade_ouvr INSTRUCTIONS accolade_ferm SINON

    then  décalage et aller à l'état 125


état 108

   51 EXPRESSION_COND: EXPRESSION_COND and . EXPRESSION_COND

    idf         décalage et aller à l'état 78
    entier_pos  décalage et aller à l'état 61
    entier_neg  décalage et aller à l'état 62
    reel_pos    décalage et aller à l'état 63
    reel_neg    décalage et aller à l'état 64
    neg         décalage et aller à l'état 79

    VALEUR           aller à l'état 80
    OPERAND          aller à l'état 81
    EXPRESSION_COND  aller à l'état 126


état 109

   52 EXPRESSION_COND: EXPRESSION_COND or . EXPRESSION_COND

    idf         décalage et aller à l'état 78
    entier_pos  décalage et aller à l'état 61
    entier_neg  décalage et aller à l'état 62
    reel_pos    décalage et aller à l'état 63
    reel_neg    décalage et aller à l'état 64
    neg         décalage et aller à l'état 79

    VALEUR           aller à l'état 80
    OPERAND          aller à l'état 81
    EXPRESSION_COND  aller à l'état 127


état 110

   41 INPUT: lire parenthese_ouvr idf parenthese_ferm . pnt_virgul

    pnt_virgul  décalage et aller à l'état 128


état 111

   46 DANS_OUTPUT: idf virgul . DANS_OUTPUT

    idf     décalage et aller à l'état 84
    chaine  décalage et aller à l'état 85

    DANS_OUTPUT  aller à l'état 129


état 112

   45 DANS_OUTPUT: chaine virgul . DANS_OUTPUT

    idf     décalage et aller à l'état 84
    chaine  décalage et aller à l'état 85

    DANS_OUTPUT  aller à l'état 130


état 113

   42 OUTPUT: output parenthese_ouvr DANS_OUTPUT parenthese_ferm . pnt_virgul

    pnt_virgul  décalage et aller à l'état 131


état 114

   60 LOOP_FOR: boucle_for idf from entier_pos . to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    to  décalage et aller à l'état 132


état 115

   59 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm . boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

    boucle_while  décalage et aller à l'état 133


état 116

    1 DEBUT: MainPrgm idf pnt_virgul var DECLARATION_LIST BeginPg accolade_ouvr INSTRUCTIONS accolade_ferm EndPg pnt_virgul .

    $défaut  réduction par utilisation de la règle 1 (DEBUT)


état 117

   15 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos corechet_ferm . pnt_virgul

    pnt_virgul  décalage et aller à l'état 134


état 118

   24 AFFECTATION_TAB: corechet_ouvr entier_pos corechet_ferm AFFECTATION_NOR .

    $défaut  réduction par utilisation de la règle 24 (AFFECTATION_TAB)


état 119

   35 EXPRESSION_ATOM: parenthese_ouvr EXPRESSION parenthese_ferm .

    $défaut  réduction par utilisation de la règle 35 (EXPRESSION_ATOM)


état 120

   27 EXPRESSION_ADD: EXPRESSION_ADD add EXPRESSION_MULT .
   30 EXPRESSION_MULT: EXPRESSION_MULT . multipl EXPRESSION_UNARY
   31                | EXPRESSION_MULT . division EXPRESSION_UNARY

    division  décalage et aller à l'état 97
    multipl   décalage et aller à l'état 98

    $défaut  réduction par utilisation de la règle 27 (EXPRESSION_ADD)


état 121

   28 EXPRESSION_ADD: EXPRESSION_ADD soustract EXPRESSION_MULT .
   30 EXPRESSION_MULT: EXPRESSION_MULT . multipl EXPRESSION_UNARY
   31                | EXPRESSION_MULT . division EXPRESSION_UNARY

    division  décalage et aller à l'état 97
    multipl   décalage et aller à l'état 98

    $défaut  réduction par utilisation de la règle 28 (EXPRESSION_ADD)


état 122

   31 EXPRESSION_MULT: EXPRESSION_MULT division EXPRESSION_UNARY .

    $défaut  réduction par utilisation de la règle 31 (EXPRESSION_MULT)


état 123

   30 EXPRESSION_MULT: EXPRESSION_MULT multipl EXPRESSION_UNARY .

    $défaut  réduction par utilisation de la règle 30 (EXPRESSION_MULT)


état 124

   50 EXPRESSION_COND: OPERAND OPERATEUR_COND OPERAND .

    $défaut  réduction par utilisation de la règle 50 (EXPRESSION_COND)


état 125

   47 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then . accolade_ouvr INSTRUCTIONS accolade_ferm SINON

    accolade_ouvr  décalage et aller à l'état 135


état 126

   51 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   51                | EXPRESSION_COND and EXPRESSION_COND .
   52                | EXPRESSION_COND . or EXPRESSION_COND

    $défaut  réduction par utilisation de la règle 51 (EXPRESSION_COND)


état 127

   51 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   52                | EXPRESSION_COND . or EXPRESSION_COND
   52                | EXPRESSION_COND or EXPRESSION_COND .

    and  décalage et aller à l'état 108

    $défaut  réduction par utilisation de la règle 52 (EXPRESSION_COND)


état 128

   41 INPUT: lire parenthese_ouvr idf parenthese_ferm pnt_virgul .

    $défaut  réduction par utilisation de la règle 41 (INPUT)


état 129

   46 DANS_OUTPUT: idf virgul DANS_OUTPUT .

    $défaut  réduction par utilisation de la règle 46 (DANS_OUTPUT)


état 130

   45 DANS_OUTPUT: chaine virgul DANS_OUTPUT .

    $défaut  réduction par utilisation de la règle 45 (DANS_OUTPUT)


état 131

   42 OUTPUT: output parenthese_ouvr DANS_OUTPUT parenthese_ferm pnt_virgul .

    $défaut  réduction par utilisation de la règle 42 (OUTPUT)


état 132

   60 LOOP_FOR: boucle_for idf from entier_pos to . entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    entier_pos  décalage et aller à l'état 136


état 133

   59 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while . parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul

    parenthese_ouvr  décalage et aller à l'état 137


état 134

   15 TYPE2: corechet_ouvr TYPE1 pnt_virgul entier_pos corechet_ferm pnt_virgul .

    $défaut  réduction par utilisation de la règle 15 (TYPE2)


état 135

   47 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr . INSTRUCTIONS accolade_ferm SINON

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 138
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 136

   60 LOOP_FOR: boucle_for idf from entier_pos to entier_pos . step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    step  décalage et aller à l'état 139


état 137

   59 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr . EXPRESSION_COND parenthese_ferm pnt_virgul

    idf         décalage et aller à l'état 78
    entier_pos  décalage et aller à l'état 61
    entier_neg  décalage et aller à l'état 62
    reel_pos    décalage et aller à l'état 63
    reel_neg    décalage et aller à l'état 64
    neg         décalage et aller à l'état 79

    VALEUR           aller à l'état 80
    OPERAND          aller à l'état 81
    EXPRESSION_COND  aller à l'état 140


état 138

   47 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS . accolade_ferm SINON

    accolade_ferm  décalage et aller à l'état 141


état 139

   60 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step . entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm

    entier_pos  décalage et aller à l'état 142


état 140

   51 EXPRESSION_COND: EXPRESSION_COND . and EXPRESSION_COND
   52                | EXPRESSION_COND . or EXPRESSION_COND
   59 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND . parenthese_ferm pnt_virgul

    parenthese_ferm  décalage et aller à l'état 143
    and              décalage et aller à l'état 108
    or               décalage et aller à l'état 109


état 141

   47 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm . SINON

    else_cond  décalage et aller à l'état 144

    $défaut  réduction par utilisation de la règle 49 (SINON)

    SINON  aller à l'état 145


état 142

   60 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step entier_pos . accolade_ouvr INSTRUCTIONS accolade_ferm

    accolade_ouvr  décalage et aller à l'état 146


état 143

   59 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm . pnt_virgul

    pnt_virgul  décalage et aller à l'état 147


état 144

   48 SINON: else_cond . accolade_ouvr INSTRUCTIONS accolade_ferm

    accolade_ouvr  décalage et aller à l'état 148


état 145

   47 CONDITION: if_cond parenthese_ouvr EXPRESSION_COND parenthese_ferm then accolade_ouvr INSTRUCTIONS accolade_ferm SINON .

    $défaut  réduction par utilisation de la règle 47 (CONDITION)


état 146

   60 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step entier_pos accolade_ouvr . INSTRUCTIONS accolade_ferm

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 149
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 147

   59 LOOP_DO: boucle_do accolade_ouvr INSTRUCTIONS accolade_ferm boucle_while parenthese_ouvr EXPRESSION_COND parenthese_ferm pnt_virgul .

    $défaut  réduction par utilisation de la règle 59 (LOOP_DO)


état 148

   48 SINON: else_cond accolade_ouvr . INSTRUCTIONS accolade_ferm

    idf         décalage et aller à l'état 29
    if_cond     décalage et aller à l'état 30
    lire        décalage et aller à l'état 31
    output      décalage et aller à l'état 32
    boucle_for  décalage et aller à l'état 33
    boucle_do   décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 16 (INSTRUCTIONS)

    INSTRUCTIONS  aller à l'état 150
    INPUT         aller à l'état 36
    OUTPUT        aller à l'état 37
    CONDITION     aller à l'état 38
    LOOP_DO       aller à l'état 39
    LOOP_FOR      aller à l'état 40


état 149

   60 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS . accolade_ferm

    accolade_ferm  décalage et aller à l'état 151


état 150

   48 SINON: else_cond accolade_ouvr INSTRUCTIONS . accolade_ferm

    accolade_ferm  décalage et aller à l'état 152


état 151

   60 LOOP_FOR: boucle_for idf from entier_pos to entier_pos step entier_pos accolade_ouvr INSTRUCTIONS accolade_ferm .

    $défaut  réduction par utilisation de la règle 60 (LOOP_FOR)


état 152

   48 SINON: else_cond accolade_ouvr INSTRUCTIONS accolade_ferm .

    $défaut  réduction par utilisation de la règle 48 (SINON)
